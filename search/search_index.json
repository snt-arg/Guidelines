{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Automation Robotics Group | Guidelines","text":"<p>Welcome to the Automation Robotics Group (ARG) guidelines repository. This is a place that you can make use throughout your stay in order to get yourself familiar with guides, conventions and safety protocols, among others.</p> <p>Furthermore, this place also includes the Aerolab &amp; Service Robots laboratory guidelines that should be followed.</p> <p>Hint</p> <p>You can you the left bar in order to navigate throughout this website. In addition, on each page, a table of contents is available on the right side.</p>"},{"location":"Organization/1.new_project/","title":"New Project","text":"<p>This page aims at giving you the knowledge on how create a new repository within the organization as well as some insights why we use GitHub teams.</p>"},{"location":"Organization/1.new_project/#why-teams","title":"Why Teams?","text":"<p>In our organization, we use teams to separate our research lines, such as situational awareness or control &amp; planning. This not only allows us to know which repository relates to each field, but it also allows the administrators to control who has access to what.</p> <p>One of the main reasons to use teams is that since one project can have more than one dependency, for someone to have access, we would need to individually add the person to each repository that is needed. With teams, we only need to have access to the team and the person would have access to all the repositories it needs.</p> <p>However, this comes at one cost. New repositories that are created need to be moved to the teams individually, otherwise, no one but the creator and the admins can see it.</p>"},{"location":"Organization/1.new_project/#creating-a-new-repository","title":"Creating a New Repository","text":"<p>Hint</p> <p>If you already know how to create a repository, jump to here</p> <p>In order to create a new project, you should go to the organization and press the new button, as shown in the picture bellow: </p> <p>Then, you should name your repository as well as toggle some checkboxes as shown in the picture bellow, highlighted in green:</p> <p>Info</p> <p>Make sure to select <code>snt-arg</code> as the owner and not yourself!</p> <p></p>"},{"location":"Organization/1.new_project/#adding-your-new-repository-to-a-team","title":"Adding your New Repository to a Team","text":"<p>As said previously, each new repository needs to be added manually to a team. However, only administrators can do this. For this reason, we use a repository that only serves as a way of you communicating that you have created a new repository in order for someone to add it. To do so, you can following steps:</p> <ol> <li>Go to this repository</li> <li>Create a new issue and fill in the missing information</li> <li>All done. Someone will then make sure you repo will be added to the correct teams.</li> </ol>"},{"location":"Organization/2.git_conventions/","title":"Git Conventions","text":"<p>Your best friend when writing software. Git is a distributed version control system that allows multiple developers to track changes, collaborate, and manage code history efficiently.</p>"},{"location":"Organization/2.git_conventions/#why","title":"Why?","text":"<p>The use of Git should be your number one tool if you do any type of software development. If you are reading this guide, the chances that you already are in our GitHub organization are high. In case you did not know, any software that you work on, whether already existing or new should all be hosted on our organization.</p> <p>In order to maintain a good consistency across all repositories in our organization, some conventions are encouraged to be followed. The conventions not only help you to manage your development, such as finding where things were added, fixed or even roll back to a working state are one the main key advantages. In addition, by following these conventions, you will be helping others and make use of automated tools to generate good CHANGELOGs for instance.</p>"},{"location":"Organization/2.git_conventions/#repositories","title":"Repositories","text":"<ul> <li>Name your repository with some meaning.</li> <li>In case a repository is used for versioning workspaces, it should be named with the project   name and carry the <code>_ws</code> suffix. Such an example is the tello_ws.</li> <li>Consider having a <code>.gitignore</code> file. You can use a generator here</li> <li>Each repository should contain a README which should give some docs about the project   and some guides to use the software.</li> </ul>"},{"location":"Organization/2.git_conventions/#branches","title":"Branches","text":""},{"location":"Organization/2.git_conventions/#recommended-branching-strategy-with-cicd-pipeline","title":"Recommended Branching Strategy with CI/CD Pipeline","text":"<p>This approach leverages a CI/CD pipeline, eliminating the need for a <code>dev</code> branch. The <code>main</code> branch is continuously updated.</p> <p>When developing a new feature or fixing a bug, create a separate branch for the task. Once the work is complete, create a pull request to merge it into the <code>main</code> branch. This PR will be run through the CI/CD pipeline, which will perform tests, verify code compilation, and more. If any checks fail, the pull request cannot be merged into the <code>main</code> branch.</p>"},{"location":"Organization/2.git_conventions/#legacy-branching-strategy-still-useful","title":"Legacy Branching Strategy (Still Useful)","text":"<p>Each repository should have at least two branches: <code>main</code> (or <code>master</code>) and <code>dev</code>. The <code>main</code> branch should always contain a stable version of the software, while the <code>dev</code> branch serves as the development branch where all new changes are made.</p> <p>When starting the implementation of a new feature or fixing a bug, you should create a new branch dedicated to the new feature or fix. This branch should be created from the <code>dev</code> branch.</p> <p>Once a branch has fulfilled its purpose, create a pull request (PR) and assign it to another team member for code review and merging into the <code>dev</code> branch.</p> <p>Hint</p> <p>Once the <code>dev</code> branch is stable, the same should be merged to the <code>main</code> branch by creating a PR.</p>"},{"location":"Organization/2.git_conventions/#branch-naming-examples","title":"Branch Naming Examples","text":"<p>Each new branch should have a prefix followed by a descriptive name. Here are some examples:</p> <ol> <li><code>feat/add-login-page</code>: Work involving adding a login page feature.</li> <li><code>fix/typo-in-header</code>: Focus on fixing a typo found in the header section.</li> <li><code>refactor/restructure-database</code>: Work involving refactoring or restructuring the database architecture.</li> <li><code>docs/update-readme</code>: Updating the project's README documentation.</li> <li><code>test/add-unit-tests</code>: Adding unit tests to the project.</li> <li><code>style/change-button-color</code>: Changing the color of buttons in the user interface.</li> <li><code>hotfix/fix-security-vulnerability</code>: A critical fix for a security vulnerability.</li> <li><code>chore/clean-up-unused-code</code>: Cleaning up unused code or files in the project.</li> </ol>"},{"location":"Organization/2.git_conventions/#commits","title":"Commits","text":"<p>Commits should be well-scoped and frequent. Each commit message should reflect on a change that has been performed, where the message should be short and straight to the point. In case some more details are needed, you can make use of the body of the message to write more details.</p> <p>Here is how a commit message should be structured:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The types of commits can be: <code>feat</code>, <code>fix</code>, <code>chore</code> ...</p> <p>Info</p> <p>For more details and why you should use convey to using this convention can be found here</p>"},{"location":"Organization/2.git_conventions/#visibility","title":"Visibility","text":"<p>All repository created should be set to private. This is because you do not own your repository but in fact it's the University of Luxembourg. Nevertheless, that does not mean you cannot make it open-source. If you want to make it open-source please have a discussion with Holger or Jose-Luis.</p>"},{"location":"Organization/2.git_conventions/#license","title":"License","text":"<p>In case you desire to make your project open-source, your repository should have a license. This license is usually selected by the TTO (Technology Transfer Office) , after a full investigation of your repo, to see if it passes all checks.</p> <p>Nevertheless, you could already create a license file when creating the repo. The license that will be applied will most likely be GPL-3.0.</p>"},{"location":"Organization/2.git_conventions/#cicd","title":"CI/CD","text":"<p>To learn how to use GitHub actions, please follow their (guide)[https://docs.github.com/en/actions].</p>"},{"location":"Organization/ros/","title":"ROS","text":"<p>Warning</p> <p>Not yet finished</p> <p>In our team, which focuses on robotics, the use of ROS should be highly encourage, if not mandatory. This not only will make sure that your work will be able to be tested on real platforms, but also streamline your work due to the amount of projects that will help evolve faster.</p> <p>Follow this guide if you are going to create a ROS package. It will help you follow the ROS standards, and maintain consistency across all our repositories. In addition, the guide streamlines the process of publishing it to the ROS index, as well as having a consistent pattern throughout our team.</p>"},{"location":"Organization/ros/#version-of-ros","title":"Version of ROS","text":"<p>There are 2 version available at the moment of writing this guide, ROS1 and ROS2. If you are about to start now, please use ROS2, choosing the distribution that is the LTS version. Currently, this is humble.</p> <p>Warning</p> <p>Please try to avoid ROS1. This is because ROS1 will reach end-of-life soon.</p>"},{"location":"Organization/ros/#starting-a-fresh-project","title":"Starting a Fresh Project","text":""},{"location":"Organization/ros/#adding-third-party-packages","title":"Adding Third Party Packages","text":"<p>There are several ways one could do that. The most common and the suggested way, is to make use of the tool vcstool. You should create a file <code>.rosinstall</code>. This file should look something like this:</p> <pre><code>repositories: # The file needs to start with this line!\n  s_graphs_utils/fast_gicp: # Path to where the package should be located\n    type: git # This most likely should not change\n    url: https://github.com/SMRT-AIST/fast_gicp.git # The package git https\n    version: master # Branch name of the package repository\n  # Another package...\n</code></pre> <p>For an example file, you can refer to unitree_ws.</p>"},{"location":"Organization/ros/#creating-a-package-within-your-package","title":"Creating a Package Within Your Package","text":"<p>In case you will create more that one package, say a message package for you package, there are 2 possible ways.</p> <p>The first one is to have them both on the repo. The structure should be like this:</p> <pre><code>package_name_root\n    - package_name\n    - package_name_msgs\n    - another package\n    - README.md\n    - .rosinstall\n    - .gitignore\n    - ...\n</code></pre> <p>The second option is to create a separate repository and then including it in the <code>.rosinstall</code>.</p> <p>Note</p> <p>You should avoid adding them as submodules. This will complicate things in case you desire to push your package to ROS index.</p>"},{"location":"Organization/ros/#workspaces","title":"Workspaces","text":"<p>Workspaces are needed when you plan on using your package in a real or virtual platform. This means that you package will no longer be a standalone package, but will work with other packages. For instance, you will need a driver for the robot or for a lidar.</p> <p>That's when a workspace will come in handy.</p> <p>To create a workspace, proceed to create a new repo, where the name should be of the form <code>&lt;project_name&gt;_ws</code>. This repo should not directly include any package. Instead, it should include scripts to setup the workspace, by getting the necessary packages, having docker files to build docker images etc. This means that you should still use vcstool for managing workspace repositories.</p> <p>Below are some files you might consider having. For a full fledged workspace, consider having a look at tello_ws or unitree_ws.</p> <pre><code>    |- .gitignore\n    |- .rosinstall\n    |- requirements.txt\n    |- Dockerfile\n    |- README.md\n    |- setup.sh\n</code></pre> <p>The <code>.rosinstall</code>file points to one or more ROS package repositories that are required by the project, and is used by <code>vcstool</code> to fetch these dependencies.</p> <p>Similarly, the <code>requirements.txt</code> file should contain a list of required Python modules, whereas the <code>Dockerfile</code> specifies how to build a Docker container for the project.</p> <p>Finally, <code>setup.sh</code> is a script that calls automates the setup of the workspace e.g., calling <code>vcstool</code>, <code>pip</code>, and so on.</p> <p>Note</p> <p>Note that except for the <code>.rosinstall</code>, all other files are optional.</p> <p></p> <p>Warning</p> <p>Other directories can be added depending on the requirements of each project, but try to keep the folder structure as compact as possible.</p> <p>Below is a description of what should be inside each of these directories.</p> <ul> <li> <p><code>/drivers</code> : This folder contains all packages providing drivers for running both simulations and the real robot. The <code>/drivers</code> directory can have sub-folders such as <code>/real</code> and <code>/simulation</code>, containing packages for executing the real world robot and the robot in simulation, respectively.</p> </li> <li> <p><code>/generic</code> : This folder contains all relevant packages for launching the processes required for successully executing a given task/mission for the project. It can be further divided into <code>/bringup</code> and <code>/description</code>. As an example, the <code>5G_sky_ws</code> workspace could have both the <code>5G_sky_bringup</code> and <code>5G_sky_description</code> subdirectories.</p> </li> <li> <p><code>/navigation</code> : This folder contains all packages required for navigation. It can be divided into sub-folders such as <code>/slam</code>, <code>/localization</code>, <code>/planning</code> and <code>/perception</code>.</p> </li> <li> <p><code>/utils</code> : This folder contains all packages that are required but not available in the form of binaries.</p> </li> <li> </li> </ul> <p>Each project will have a bringup repository and a description repository, these repos will be named as project_bringup and project_description.</p> <ul> <li> <p>project_bringup : The project_bringup as the name suggests is responsible for bringing up all the processes responsible for proper execution of the robot and its sensors, where it be in a simulated environment or in real world. Basically it has all the launch and config files of the different packages which are grouped together to launch an entire mission of the robot. How to create a bringup repo (example: <code>5G_sky_bringup</code>):</p> <pre><code>cd ~/workspace/ros/5G_sky_ws/src/generic &amp;&amp; catkin_create_pkg 5G_sky_bringup roscpp rospy\ncd 5G_sky_bringup &amp;&amp; mkdir launch &amp;&amp; mkdir config\n</code></pre> <p>The above command creates a ros repo, it also adds <code>launch</code> and <code>config</code> folders. You have to push this created ros repo to github.</p> </li> <li> <p>project_description : As the name suggests the project description contains the description files the projects. The description file contains the urdfs, meshes, worlds etc for the robots and the environment of the robot.</p> <pre><code>cd ~/workspace/ros/5G_sky_ws/src/generic &amp;&amp; catkin_create_pkg 5G_sky_description\ncd 5G_sky_description &amp;&amp; mkdir launch &amp;&amp; mkdir config &amp;&amp; mkdir urdf &amp;&amp; mkdir worlds\n</code></pre> <p>The above command will create a ros repo which will have <code>launch</code>, <code>config</code>, <code>urdf</code> and <code>worlds</code> folders.</p> </li> <li> </li> </ul> <p>You should also clone all the relevant ros packages that do not have binaries and need to installed in the project_ws in the relevant folders. For example if we need a ros package of <code>hdl_graph_slam</code> inside our <code>5G_sky_ws</code> you can clone it inside the folder navigation/SLAM</p> <ul> <li> </li> </ul> <p>Once you have all the repos cloned just perform the command below to create a <code>.rosinstall</code> file which will contain the entire repository management.</p> <pre><code>cd ~/workspace/ros/5G_sky_ws &amp;&amp; touch .rosinstall\nvcs export src &gt; .rosinstall\ngit add .rosinstall &amp;&amp; git commit -m 'added .rosinstall'\ngit push\n</code></pre>"},{"location":"Organization/ros/#example-workspace-structure","title":"Example Workspace Structure","text":""},{"location":"Organization/ros/#create-project-bringup-project-description","title":"Create Project Bringup &amp; Project Description:","text":""},{"location":"Organization/ros/#clone-all-remaining-required-repos","title":"Clone All Remaining Required Repos:","text":""},{"location":"Organization/ros/#upload-workspace-management-file","title":"Upload Workspace Management File:","text":""},{"location":"Organization/ros/#releasing-package-to-ros-index","title":"Releasing Package to ROS Index","text":"<p>TODO</p>"},{"location":"Robots/spot/","title":"Spot","text":""},{"location":"Robots/unitree/","title":"Unitree Go1","text":"<p>Unitree Go1 is one of our legged robots. In this page, we provide the instructions that one needs to know to either teleoperate as well as controlling it using ROS.</p>"},{"location":"Robots/unitree/#teleoperation-with-remote","title":"Teleoperation with Remote","text":"<ol> <li>Place battery in robot</li> <li>Power on robot: Short press and then long press the battery power button</li> <li>Power remote: short press and then long press power button</li> <li>Wait for robot to stand</li> <li>Follow instructions on remote</li> <li>Sit: 2x L2+A -&gt; L2+B</li> <li>Stand: 2x L2+A -&gt; SELECT</li> <li>Power off robot: Sit robot first and then repeat step 2.</li> </ol>"},{"location":"Robots/unitree/#control-using-ros","title":"Control using ROS","text":"<p>A ROS package is available to control the robot using ROS velocity commands as well as receive data from robot. You can install it using the following command:</p> <pre><code>sudo apt install ros-&lt;distro&gt;-unitree-ros\n</code></pre> <p>Note</p> <p>Only humble and iron are supported. For the foxy devel, please consult package repo</p> <p>Then, to control the robot, first connect to it's hotspot. The <code>SSID</code> should be the one containing GO1 on it. For the password, refer to here. Once connected, run the following command:</p> <pre><code>ros2 launch unitree_ros unitree_driver_launch.py wifi:=true\n</code></pre> <p>In case you are connected to the robot via cable, no need to connect to WiFi. Simply run <code>ros2 launch unitree_ros unitree_driver_launch.py</code></p> <p>More on the ROS package</p> <p>In case you desire to know more about what the package offers, please refer to it's documentation.</p>"},{"location":"Robots/unitree/#system-architecture","title":"System Architecture","text":"<p>The following picture illustrates well each component available inside the robot.</p> <p></p> <ul> <li>Has 4 computers</li> <li> <p>Has 5 Depth cameras</p> <ul> <li>Front</li> <li>Left &amp; Right</li> <li>Bottom front</li> <li>Bottom back</li> </ul> </li> <li> <p>Has 3 ultrasonic sensors</p> </li> </ul>"},{"location":"Robots/unitree/#computer-ips","title":"Computer IPs","text":"<ul> <li>Main control board: MCU (<code>192.168.123.10</code>)</li> <li>Motion Control Board: Raspberry Pi 4B (<code>192.168.123.161</code>)</li> <li>Sensing motherboard: Nano (head, <code>192.168.123.13</code>)</li> <li>Nano (body, <code>192.168.123.14</code>)</li> <li>Nano (body, <code>192.168.123.15</code>)</li> </ul>"},{"location":"Robots/unitree/#resources","title":"Resources","text":"<p>For more information on the unitree SDK, you can find the docs here</p>"}]}